<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Johannes Titz" />


<title>Introduction to fastpos</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to fastpos</h1>
<h4 class="author">Johannes Titz</h4>
<h4 class="date">January, 2020</h4>



<p>The R package <em>fastpos</em> provides a fast algorithm to calculate the required sample size for a Pearson correlation to stabilize within a sequential framework <span class="citation">(Schönbrodt &amp; Perugini, 2013, 2018)</span>. Basically, one wants to find the sample size at which one can be sure that 1-α percent of many studies will fall into a specified corridor of stability around an assumed population correlation and stay inside that corridor if more participants are added to the study. For instance, find out <em>how many</em> participants per study are required so that, out of 100k studies, 90% would fall into the region between .4 to .6 (a Pearson correlation) and not leave this region again when more participants are added (under the assumption that the population correlation is .5). This sample size is also referred to as the <em>critical point of stability</em> for the specific parameters.</p>
<p>This approach is related to accuracy in parameter estimation <span class="citation">(AIPE, e.g. Maxwell, Kelley, &amp; Rausch, 2008)</span> and as such can be seen as an alternative to power analysis. Unlike AIPE, the concept of <em>stability</em> incorporates the idea of sequentially adding participants to a study. Although the approach is young, it has already attracted a lot of interest in the psychological research community, which is evident in over 600 citations of the original publication <span class="citation">(Schönbrodt &amp; Perugini, 2013)</span>. To date there exists no easy way to use sequential stability for individual sample size planning because there is no analytical solution to the problem and a simulation approach is computationally expensive. The package <em>fastpos</em> overcomes this limitation by speeding up the calculation of correlations. For typical parameters, the theoretical speedup should be at least around 250. An empirical benchmark for a typical scenario even shows a speedup of about 500, paving the way for a wider usage of the <em>stability</em> approach.</p>
<p>If you have found this page, I assume you either want to (1) calculate the critical point of stability for your own study or (2) explore the method in general. If this is the case, read on and you should find what you are looking for. Let us first load the package and set a seed for reproducibility:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(fastpos)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">set.seed</span>(<span class="dv">19950521</span>)</span></code></pre></div>
<p>In most cases you will just need the function <strong>find_critical_pos</strong> which will give you the critical point of stability for your specific parameters.</p>
<p>Let us reproduce one example from Schönbrodt and Perugini’s work (this should take only a couple of seconds on a modern CPU):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">find_critical_pos</span>(<span class="dt">rho =</span> <span class="fl">.7</span>, <span class="dt">sample_size_min =</span> <span class="dv">20</span>, <span class="dt">sample_size_max =</span> <span class="dv">1000</span>,</span>
<span id="cb2-2"><a href="#cb2-2"></a>                  <span class="dt">n_studies =</span> <span class="dv">10000</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">#&gt;   rho_pop 80% 90% 95% sample_size_min sample_size_max lower_limit upper_limit</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">#&gt; 1     0.7  65  96 127              20            1000         0.6         0.8</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">#&gt;   n_studies n_not_breached precision precision_rel</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">#&gt; 1     10000              0       0.1         FALSE</span></span></code></pre></div>
<p>The result is very close to Schönbrodt and Perugini’s table (see <a href="https://github.com/nicebread/corEvol" class="uri">https://github.com/nicebread/corEvol</a>).</p>
<p>Note that <strong>find_critical_pos</strong> will throw a message if at least one study did not reach the corridor of stability with the maximum sample size. This happened in Schönbrodt and Perugini’s work, but quite seldom. Still, it should be be avoided for a proper estimate of the point of stability.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">find_critical_pos</span>(<span class="dt">rho =</span> <span class="fl">.7</span>, <span class="dt">sample_size_min =</span> <span class="dv">20</span>, <span class="dt">sample_size_max =</span> <span class="dv">400</span>,</span>
<span id="cb3-2"><a href="#cb3-2"></a>                  <span class="dt">n_studies =</span> <span class="dv">10000</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">#&gt; Warning in find_critical_pos(rho = 0.7, sample_size_min = 20, sample_size_max = 400, : 3 simulation[s] did not reach the corridor of</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">#&gt;             stability.</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">#&gt; Increase sample_size_max and rerun the simulation.</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">#&gt;   rho_pop 80% 90% 95% sample_size_min sample_size_max lower_limit upper_limit</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">#&gt; 1     0.7  65  97 133              20             400         0.6         0.8</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co">#&gt;   n_studies n_not_breached precision precision_rel</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">#&gt; 1     10000              3       0.1         FALSE</span></span></code></pre></div>
<p>In this case, do what the message suggests and increase the maximum sample size. Note that larger sample sizes are more resource intensive because the correlations are calculated in the reverse way (from the maximum sample size downwards). Thus, you usually would not like to increase the maximum sample size, unless there are studies that did not reach the corridor of stability.</p>
<p>If you need different confidence levels, just state it:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">find_critical_pos</span>(<span class="dt">rho =</span> <span class="fl">.7</span>, <span class="dt">sample_size_min =</span> <span class="dv">20</span>, <span class="dt">sample_size_max =</span> <span class="dv">1000</span>,</span>
<span id="cb4-2"><a href="#cb4-2"></a>                  <span class="dt">n_studies =</span> <span class="dv">10000</span>, <span class="dt">confidence_levels =</span> <span class="kw">c</span>(.<span class="dv">6</span>, <span class="fl">.85</span>))</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">#&gt;   rho_pop 60% 85% sample_size_min sample_size_max lower_limit upper_limit</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">#&gt; 1     0.7  38  78              20            1000         0.6         0.8</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#&gt;   n_studies n_not_breached precision precision_rel</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#&gt; 1     10000              0       0.1         FALSE</span></span></code></pre></div>
<p>This has no effect on resource consumption because the time consuming part is to simulate the distribution, not calculating quantiles of the distribution.</p>
<p>If you need a different precision level or even relative precision, specify it:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">find_critical_pos</span>(<span class="dt">rho =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.7</span>), <span class="dt">sample_size_min =</span> <span class="dv">20</span>, <span class="dt">sample_size_max =</span> <span class="dv">2500</span>,</span>
<span id="cb5-2"><a href="#cb5-2"></a>                  <span class="dt">n_studies =</span> <span class="dv">10000</span>, <span class="dt">precision =</span> <span class="fl">.10</span>, <span class="dt">precision_rel =</span> T)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">#&gt; Warning in find_critical_pos(rho = c(0.5, 0.7), sample_size_min = 20, sample_size_max = 2500, : 10 simulation[s] did not reach the corridor of</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">#&gt;             stability.</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">#&gt; Increase sample_size_max and rerun the simulation.</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">#&gt;   rho_pop   80%   90%  95% sample_size_min sample_size_max lower_limit</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">#&gt; 1     0.5 590.0 845.2 1122              20            2500        0.45</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">#&gt; 2     0.7 135.2 199.0  264              20            2500        0.63</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">#&gt;   upper_limit n_studies n_not_breached precision precision_rel</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">#&gt; 1        0.55     10000             10       0.1          TRUE</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">#&gt; 2        0.77     10000              0       0.1          TRUE</span></span></code></pre></div>
<p>As you can see in the output, the limits were set relatively to the population correlation (+-25% of the population correlation).</p>
<p>If you want to dig deeper, you can have a look at the functions that <em>find_critical_pos</em> builds upon. <strong>simulate_pos</strong> is the workhorse of the package. It calls a C++ function to calculate correlations sequentially and it does this pretty quickly (but you know that already, right?). A rawish approach would be to create a population with <strong>create_pop</strong> and pass it to <strong>simulate_pos</strong>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>pop &lt;-<span class="st"> </span><span class="kw">create_pop</span>(<span class="fl">0.5</span>, <span class="dv">1000000</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a>pos &lt;-<span class="st"> </span><span class="kw">simulate_pos</span>(<span class="dt">x_pop =</span> pop[,<span class="dv">1</span>],</span>
<span id="cb6-3"><a href="#cb6-3"></a>                    <span class="dt">y_pop =</span> pop[,<span class="dv">2</span>],</span>
<span id="cb6-4"><a href="#cb6-4"></a>                    <span class="dt">n_studies =</span> <span class="dv">1000</span>,</span>
<span id="cb6-5"><a href="#cb6-5"></a>                    <span class="dt">sample_size_min =</span> <span class="dv">20</span>,</span>
<span id="cb6-6"><a href="#cb6-6"></a>                    <span class="dt">sample_size_max =</span> <span class="dv">1000</span>,</span>
<span id="cb6-7"><a href="#cb6-7"></a>                    <span class="dt">replace =</span> T,</span>
<span id="cb6-8"><a href="#cb6-8"></a>                    <span class="dt">lower_limit =</span> <span class="fl">0.4</span>,</span>
<span id="cb6-9"><a href="#cb6-9"></a>                    <span class="dt">upper_limit =</span> <span class="fl">0.6</span>)</span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">hist</span>(pos, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1000</span>), <span class="dt">xlab =</span> <span class="kw">c</span>(<span class="st">&quot;Point of stability&quot;</span>),</span>
<span id="cb6-11"><a href="#cb6-11"></a>     <span class="dt">main =</span> <span class="st">&quot;Histogram of points of stability for rho = .5+-.1&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">quantile</span>(pos, <span class="kw">c</span>(.<span class="dv">8</span>, <span class="fl">.9</span>, <span class="fl">.95</span>), <span class="dt">na.rm =</span> T)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">#&gt;    80%    90%    95% </span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">#&gt; 142.20 199.10 290.05</span></span></code></pre></div>
<p>Note that no warning message appears if the corridor is not reached, but instead an NA value is returned. Pay careful attention if you work with this function, and adjust the maximum sample size as needed.</p>
<p><strong>create_pop</strong> creates the population matrix by using <strong>mvrnorm</strong>. This is a much simpler way than Schönbrodt and Perugini’s approach, but the results do not seem to differ. If you are interested in how population parameters (e.g. skewness) affect the point of stability, you should instead refer to the population generating functions in Schönbrodt and Perugini’s work.</p>
<p>As you can see, there is not really much to the sequential definition of stability, except for calculating billions of correlations. This is done quite fast with the help of <strong>Rcpp</strong>.</p>
<p>Let us reproduce Schönbrodt and Perugini’s quite famous and oft-cited table of the critical points of stability for a precision of 0.1. We set the maximum sample size a bit higher, so we avoid studies where the corridor is never reached. We reduce the number of studies to 10k so that it runs fairly quickly.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">find_critical_pos</span>(<span class="dt">rho =</span> <span class="kw">seq</span>(.<span class="dv">1</span>, <span class="fl">.7</span>, <span class="fl">.1</span>), <span class="dt">sample_size_max =</span> <span class="dv">1000</span>,</span>
<span id="cb8-2"><a href="#cb8-2"></a>                  <span class="dt">n_studies =</span> <span class="dv">10000</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">#&gt; Warning in find_critical_pos(rho = seq(0.1, 0.7, 0.1), sample_size_max = 1000, : 22 simulation[s] did not reach the corridor of</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">#&gt;             stability.</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">#&gt; Increase sample_size_max and rerun the simulation.</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co">#&gt;   rho_pop   80%   90%    95% sample_size_min sample_size_max lower_limit</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">#&gt; 1     0.1 254.0 366.1 489.00              20            1000         0.0</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">#&gt; 2     0.2 235.2 340.0 443.05              20            1000         0.1</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">#&gt; 3     0.3 211.0 303.1 396.00              20            1000         0.2</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">#&gt; 4     0.4 179.0 260.0 350.00              20            1000         0.3</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co">#&gt; 5     0.5 144.2 211.0 276.05              20            1000         0.4</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="co">#&gt; 6     0.6 102.0 149.0 198.05              20            1000         0.5</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co">#&gt; 7     0.7  66.0  97.0 128.05              20            1000         0.6</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="co">#&gt;   upper_limit n_studies n_not_breached precision precision_rel</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">#&gt; 1         0.2     10000              9       0.1         FALSE</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="co">#&gt; 2         0.3     10000              7       0.1         FALSE</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="co">#&gt; 3         0.4     10000              1       0.1         FALSE</span></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="co">#&gt; 4         0.5     10000              5       0.1         FALSE</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co">#&gt; 5         0.6     10000              0       0.1         FALSE</span></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="co">#&gt; 6         0.7     10000              0       0.1         FALSE</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="co">#&gt; 7         0.8     10000              0       0.1         FALSE</span></span></code></pre></div>
<p>You can obviously parallelize the process, which will be especially useful if you want to run many simulations. For instance, if you increase the number of studies to 100k (as in the original article), it will take less than a minute on a modern CPU with several cores. On my i7-2640 with 4 cores, it takes about 30 s. Overall, this speedup is substantial compared to the original implementation. A rough benchmark can be found here: <a href="https://github.com/johannes-titz/fastpos" class="uri">https://github.com/johannes-titz/fastpos</a> which results in a speedup of about 500 for a typical scenario.</p>
<p>If you are interested in this package, there is still some work to do and I am happy if you like to contribute. Specifically, I would like to use RcppParallel to speed up the simulation directly in C++. This is rather of academic interest, as the functions are fast enough to find the critical point of stability for an individual study in a few seconds for most use cases. Indeed, I hope the package will be used this way—quite similar to a power analysis for significance testing.</p>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-maxwell2008">
<p>Maxwell, S. E., Kelley, K., &amp; Rausch, J. R. (2008). Sample size planning for statistical power and accuracy in parameter estimation. <em>Annual Review of Psychology</em>, <em>59</em>, 537–563. <a href="https://doi.org/10.1146/annurev.psych.59.103006.093735">https://doi.org/10.1146/annurev.psych.59.103006.093735</a></p>
</div>
<div id="ref-schonbrodt2013">
<p>Schönbrodt, F. D., &amp; Perugini, M. (2013). At what sample size do correlations stabilize? <em>Journal of Research in Personality</em>, <em>47</em>, 609–612. <a href="https://doi.org/10.1016/j.jrp.2013.05.009">https://doi.org/10.1016/j.jrp.2013.05.009</a></p>
</div>
<div id="ref-schonbrodt2018">
<p>Schönbrodt, F. D., &amp; Perugini, M. (2018). Corrigendum to “At What Sample Size Do Correlations Stabilize?” [J. Res. Pers. 47 (2013) 609–612]. <em>Journal of Research in Personality</em>, <em>74</em>, 194. <a href="https://doi.org/10.1016/j.jrp.2018.02.010">https://doi.org/10.1016/j.jrp.2018.02.010</a></p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
